QUEUE CLASS EXPLANATION
====================

CLASS Queue<T>:
    // This is our First-In-First-Out (FIFO) queue implementation
    // Think of it like a line of people waiting - first person to join is first to leave

    // These are the basic properties our queue needs
    PRIVATE elements: Array of Object    // Array to store our items
    PRIVATE head: Integer               // Points to the front of the queue
    PRIVATE tail: Integer               // Points to where next item goes
    PRIVATE size: Integer               // How many items are in the queue
    PRIVATE INITIAL_CAPACITY = 10       // Start with room for 10 items

    // Constructor - sets up an empty queue
    CONSTRUCTOR Queue():
        elements = NEW Array[INITIAL_CAPACITY]  // Create empty array
        head = 0                               // Front starts at position 0
        tail = 0                              // Next item also goes at 0
        size = 0                              // No items yet

    // Add a new item to the back of the queue
    METHOD enqueue(item: T):
        // If queue is full, make it bigger
        IF size EQUALS elements.length THEN:
            resize()
        
        elements[tail] = item                     // Put new item at tail
        tail = (tail + 1) % elements.length       // Move tail to next position
        size = size + 1                          // One more item in queue

    // Remove and return the item from the front
    METHOD dequeue() RETURNS T:
        IF isEmpty() THEN:
            THROW RuntimeException("Queue is empty")
        
        item = (T) elements[head]                // Get front item
        elements[head] = null                    // Clear reference
        head = (head + 1) % elements.length      // Move head to next
        size = size - 1                         // One less item
        RETURN item

    // Look at front item without removing it
    METHOD peek() RETURNS T:
        IF isEmpty() THEN:
            THROW RuntimeException("Queue is empty")
        RETURN (T) elements[head]

    // Check if queue is empty
    METHOD isEmpty() RETURNS Boolean:
        RETURN size EQUALS 0

    // Get current number of items
    METHOD size() RETURNS Integer:
        RETURN size

    // Make the queue bigger when it's full
    PRIVATE METHOD resize():
        newCapacity = elements.length * 2           // Double the size
        newElements = NEW Array[newCapacity]        // Create bigger array
        // Copy all items to new array, starting at position 0
        FOR i = 0 TO size - 1:
            newElements[i] = elements[(head + i) % elements.length]
        elements = newElements                      // Use new array
        head = 0                                   // Reset head to start
        tail = size                               // tail goes after last item

    // Convert queue contents to regular array
    METHOD toArray() RETURNS Array of Object:
        result = NEW Array[size]
        // Copy all items in proper order
        FOR i = 0 TO size - 1:
            result[i] = elements[(head + i) % elements.length]
        RETURN result

END CLASS

EXPLANATION OF HOW QUEUE WORKS:
----------------------------
Think of it like a line at a store:

1. New customers (items) join at the back (tail)
2. Customers are served (removed) from the front (head)
3. If the line gets too long, we make more space (resize)
4. We can check how many people are in line (size)
5. We can see who's next without serving them (peek)

USAGE EXAMPLE:
------------
queue = NEW Queue()
queue.enqueue("First")     // ["First"]
queue.enqueue("Second")    // ["First", "Second"]
queue.enqueue("Third")     // ["First", "Second", "Third"]

item = queue.dequeue()     // item = "First", queue = ["Second", "Third"]
next = queue.peek()        // next = "Second" (still in queue)
count = queue.size()       // count = 2

CIRCULAR ARRAY EXPLANATION:
------------------------
We use a circular array to save space. Imagine a circular table:
- When we reach the end, we wrap around to the start
- head points to the first item
- tail points to where the next item goes
- We use modulo (%) to wrap around: position 11 in size 10 becomes position 1

This is more efficient than shifting all items when we remove from the front. 